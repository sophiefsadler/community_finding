"""
Calculate the node-pair features for every graph, given the coassociation matrix
produced by each of the algorithms.

The graphs_folder input must be a folder of the structure generated by
graph_gen.py.

The experiment_folder must contain a folder called Runs generated by partition_gen
and a folder called Coassociation generated by coassociation_gen.

Usage:
  pair_feature_calc.py <graphs_folder> <experiment_folder>

Options:
  -h --help            Show this help message

"""

import os
import yaml
import math
import numpy as np
import pandas as pd
import networkx as nx
from networkx.algorithms.centrality import edge_betweenness_centrality
from scipy.stats import entropy

from docopt import docopt
from tqdm import tqdm, trange


def calc_pair_metrics(G, n_nodes):
    pair_metrics = {'Common Neighbours': {}, 'Jaccard': {}, 'Cosine Similarity': {}, 
                    'Shortest Path': {}, 'Max Edge Centrality': {}}

    edge_centralities = edge_betweenness_centrality(G)
    node_degrees = dict(G.degree())

    for i in trange(n_nodes):
        for j in range(i+1, n_nodes):

            jaccard = nx.jaccard_coefficient(G, [(i,j)])
            pair_metrics['Jaccard']['nodes_{0}_{1}'.format(i,j)] = next(jaccard)[2]

            neighbours = len(list(nx.common_neighbors(G, i, j)))
            pair_metrics['Common Neighbours']['nodes_{0}_{1}'.format(i,j)] = neighbours

            cosine = neighbours / (math.sqrt(node_degrees[i]) * math.sqrt(node_degrees[j]))
            pair_metrics['Cosine Similarity']['nodes_{0}_{1}'.format(i,j)] = cosine

            shortest_path = nx.shortest_path(G, source=i, target=j)
            path_length = len(shortest_path) - 1
            pair_metrics['Shortest Path']['nodes_{0}_{1}'.format(i,j)] = path_length

            max_edge_centrality = 0
            for k in range(path_length - 1):
                current_edge_centrality = edge_centralities[tuple(sorted((shortest_path[k], shortest_path[k+1])))]
                if current_edge_centrality > max_edge_centrality:
                    max_edge_centrality = current_edge_centrality
            pair_metrics['Max Edge Centrality']['nodes_{0}_{1}'.format(i,j)] = max_edge_centrality

    return pair_metrics     


if __name__ == '__main__':
    args = docopt(__doc__)
    graphs_folder = args.get('<graphs_folder>')
    experiment_folder = args.get('<experiment_folder>')

    if not os.path.exists(os.path.join(experiment_folder, 'Pair_Features')):
        os.mkdir(os.path.join(experiment_folder, 'Pair_Features'))

    if not os.path.exists(os.path.join(experiment_folder, 'Pair_Entropies')):
        os.mkdir(os.path.join(experiment_folder, 'Pair_Entropies'))

    for graph_loc in os.listdir(graphs_folder):

        graph_loc = os.path.join(graphs_folder, graph_loc)
        graph_contents = os.listdir(graph_loc)
        graph_yml = [x for x in graph_contents if x.endswith('yml')][0]
        with open(os.path.join(graph_loc, graph_yml)) as f:
            graph_info = yaml.load(f, Loader=yaml.Loader)
        G = graph_info['G']
        n_nodes = graph_info['n']

        coassociation_npy = graph_yml.split('.')[0] + '_coassociation.npy'
        coassociation_file = os.path.join(experiment_folder, 'Coassociation', coassociation_npy)
        C = np.load(coassociation_file)

        pair_metrics = calc_pair_metrics(G, n_nodes)
        features = pd.DataFrame(pair_metrics)
        features_path = os.path.join(experiment_folder, 'Pair_Features', graph_yml.split('.')[0] + '_features.csv')
        features.to_csv(features_path)

        entropies = []
        for i in range(n_nodes):
            for j in range(i+1, n_nodes):
                entropies.append(C[i,j])
        entropies = np.array(entropies)
        node_entropies = pd.DataFrame(entropies, index=features.index, columns=['Entropy'])
        entropies_path = os.path.join(experiment_folder, 'Pair_Entropies', graph_yml.split('.')[0] + '_entropies.csv')
        node_entropies.to_csv(entropies_path)

